# Используем Entities в своем проекте

>	**NOTE:** Entities нужны для модульности, легко расширяемая система для построения и повторного использования пользовательских строительных блоков. В настоящий момент, поддержка entities только начинается, и в основном сосредоточена вокруг поддержки ~{ шейдинга окружения и пост-эффектов }~. Не стесняйтесь использовать систему сущности для других целей, используя любую информацию, которую вы видите в этом разделе, но имейте в виду, что на данный момент большинство рабочих процессов по-прежнему основаны на использовании *units* а не entities. См. также ~{ О units и entities }~.

Entities являются строительными блоками, которые вы можете использовать в своем проекте для создания сложных объектов, которые имеют свои собственные уникальные наборы данных, поведения и интерактивности.

## Для чего нужны сущности?

TЦель системы сущностей - быть гибкой и достаточно открытой, чтобы моделировать практически любой объект, который вам может понадобиться в вашем проекте.

Под капотом несколько основных функций и рабочих процессов уже построены на основе entities. Например, в любое время, когда вы создаете новый уровень, он поставляется с сущностью, которая обрабатывает параметры рендеринга, используемые в ~{ The Shading environment and post effects }~.

Вы также можете напрямую использовать систему сущностей для настройки своих видов объектов. В этом выпуске вы найдете его в основном полезным для создания объектов, которые хранят произвольные значения данных: numeric, boolean, strings, resource names, 3D coordinates, colors.

## Entities это *модульность*

Каждая сущность представляет собой контейнер, который содержит различные виды *components*.

Каждый компонент имеет отдельную конкретную работу. Это может быть как хранение данных, управление трехмерной сеткой, сохранение иерархии других вложенных объектов, реагирование на события путем запуска кода Lua или Flow graphs.

Вы собираете сущность, комбинируя различные компоненты и настраивая их своими собственными данными (например различные значения свойств, различные меши, разные типы поведения). Таким образом, вы можете * составить * свои собственные уникальные типы сущностей, которые содержат только компоненты и поведение, которые вам нужны.

См также ~{ назначение компонента в сущность }~.

## Entities это *эффективность*

Поскольку объекты создаются из выбранного набора компонентов, они, как правило, относительно легки. Если вам не нужна сущность для обработки таких вещей, как физика или 3D-сетки, вы просто не назначаете соответствующие компоненты этому объекту. Поэтому каждый объект потребляет только минимальный объем памяти, необходимый для обработки назначенных ему компонентов, не оставляя лишних «накладных расходов»,.

Кроме того, каждый тип компонента управляется отдельной подсистемой. Каждый из этих менеджеров компонентов знает только объекты, которым был назначен экземпляр своего компонента, и каждый менеджер сохраняет все соответствующие данные для всех этих объектов в одном месте. Развязка менеджеров компонентов таким образом делает каждого менеджера максимально целенаправленным и эффективным при выполнении своей конкретной работы.

## Entities это *расширяемость*

{{ProductName}} поставляется с некоторыми встроенными компонентами, которые готовы быть привязаны к вашим собственным объектам. (В этом выпуске набор компонентов, которые имеют полные сквозные рабочие процессы от редактора до игрового процесса исполнения, очень ограничен. В будущих выпусках будут добавлены дополнительные встроенные типы компонентов и более простые способы их настройки.)

В зависимости от типа проекта, который вы создаете, вам могут потребоваться, чтобы ваши объекты выполняли разные виды заданий или управляли различными видами данных, чем набор встроенных компонентов.

Для этого вы можете создавать свои собственные настраиваемые типы компонентов. Это позволяет вам приспособить свои сущности в соответствии с потребностями вашего проекта очень близко.

См. также ~{ Создание кастомного компонента }~.

## Entities это *повторно-используемость*

Вы можете создавать новые определения сущностей для других типов объектов, которые вы уже настроили. Это заставляет ваш новый объект * наследовать * все те же компоненты и настройки, что и его базовый объект. Вы также можете переопределить любой из этих унаследованных параметров и добавить новые компоненты.

Это означает, что вам никогда не придется дублировать определение сущности, чтобы повторно использовать один и тот же набор компонентов или настроек. Вы можете повторно использовать каждое определение сущности столько раз, сколько вам нужно, специализируясь на этом каждый раз, когда вы его используете.

Это позволяет создавать иерархии определений сущностей, каждый из которых зависит от компонентов и настроек, которые исходят из *наследования активов*.

Обратите внимание, что каждый объект постоянно связан с его унаследованным объектом. Всякий раз, когда вы извлекаете унаследованный параметр, его значение извлекается из унаследованного объекта, если оно не было переопределено. Поэтому, когда вы изменяете настройку в корне вашей иерархии объектов, вы автоматически изменяете это значение для всех других объектов, которые наследуют его.

См также ~{ установка или удаление inherited asset }~ и ~{ Применени и сброс overrides }~.
